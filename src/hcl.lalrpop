use std::str::FromStr;
use crate::ast;

grammar;

pub Hcl: () = {
    Body,
};

Body: () = {
    <b:BlockList> => { println!("Blocklist: {:#?}", b) },
    AttributeList,
};

BlockList: Vec<ast::Block> = {
    <mut bl:BlockList> <b:Block> => {
        bl.push(b);
        bl
    },
    <b:Block> => {
        vec![b]
    },
};

AttributeList: () = {
    AttributeList Attribute,
    Attribute,
};

Attribute: () = {
    Identifier "=" Expression,
};

Block: ast::Block = {
    <i:Identifiers+> "{" Body "}" => {
        ast::Block {
            block_identifiers: i
        }
    },
};

IdentifierList: () = {
    IdentifierList Identifiers,
    Identifiers,
};

Identifiers: String = {
    Identifier,
    QuotedIdentifier,
};

Expression: () = {
    Operation,
    Conditional,
    TemplateInterpolation,
};

TemplateInterpolation: () = {
    "${" ExprTerm "}",
    "${" "~" ExprTerm "~" "}",
};

Conditional: () = {
    ExprTerm "?" ExprTerm ":" ExprTerm,
};

// Precedence: highest to lowest.
// Level    Operators
//   6      * / %
//   5      + -
//   4      > >= < <=
//   3      == !=
//   2      &&
//   1      ||
Operation: () = {
    OperationUnary,
    OperationBinary,
};

OperationUnary: () = {
    "-" ExprTerm,
    "!" ExprTerm,
};

OperationBinary: () = {
    OperationOr,
};

// Precedence is created by adding nonterminals with higher precedence to the production rules.
// "Itself plus its child"
// '||' has the lowest precedence.
OperationOr: () = {
    OperationOr "||" OperationAnd,
    OperationAnd,
};

OperationAnd: () = {
    OperationAnd "&&" OperationEq,
    OperationEq,
};

OperationEq: () = {
    OperationEq "==" OperationComp,
    OperationEq "!=" OperationComp,
    OperationComp,
};

OperationComp: () = {
    OperationComp ">" OperationAddSub,
    OperationComp "<" OperationAddSub,
    OperationComp ">=" OperationAddSub,
    OperationComp "<=" OperationAddSub,
    OperationAddSub,
};

OperationAddSub:() = {
    OperationAddSub "+" OperationMulDiv,
    OperationAddSub "-" OperationMulDiv,
    OperationMulDiv,
};

OperationMulDiv: () = {
    OperationMulDiv "*" ExprTerm,
    OperationMulDiv "/" ExprTerm,
    OperationMulDiv "%" ExprTerm,
    ExprTerm,
};

ExprTerm: () = {
    LiteralValue,
    CollectionValue,
    // TemplateExpr,  // TODO: it can't parse newlines for some reason
    VariableExpr,
    FunctionCall,
    ForExpr,
    ExprTerm Splat,
    "(" Expression ")",
};

LiteralValue:() = {
    Number,
    "true",
    "false",
    "null",
};

CollectionValue: () = {
    Tuple,
    Object,
};

Tuple: () = {
    "[" ExpressionCommaList? "]",
};

ExpressionCommaList: () = {

    Expression "," ExpressionCommaList,
    Expression,
};

Object: () = {
    "{" ObjectCommaList? "}",
};

ObjectCommaList: () = {
    Expression "=" Expression,
    Expression "=" Expression "," ObjectCommaList
};


Splat: () = {
    "." "*",
    "." Identifier,     // GetAttr
    "[" "*" "]",
    "[" Expression "]", // Index
};

FunctionCall: () = {
    Identifier "(" Arguments? ")"
};

Arguments: () = {
    ExpressionCommaList
};

ForExpr: () = {
    ForTupleExpr,
    ForObjectExpr,
};

ForTupleExpr: () = {
    "[" ForIntro Expression ForCond? "]"
};

ForObjectExpr: () = {
    "{" ForIntro Expression "=>" Expression "..."? ForCond? "}"
};

ForIntro: () = {
    "for" IdentifierCommaList "in" Expression ":"
};

ForCond: () = {
    "if" Expression
};

IdentifierCommaList: () = {
    Identifier,
    Identifier "," IdentifierCommaList
};

VariableExpr: () = {
    Identifiers,
};

TemplateExpr: () = {
    // TODO: quotedTemplate (a double-quoted string with escaped quotes)
    Heredoc Identifier "\n" IdentifierList "\n"
};

QuotedIdentifier: String = r#""[a-zA-Z]+""# => <>.to_string();
Identifier: String = r#"[a-zA-Z]+"# => <>.to_string();
Number: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
Heredoc: String = r"<<-?" => <>.to_string();
