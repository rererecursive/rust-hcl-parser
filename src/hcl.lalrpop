use std::str::FromStr;
use crate::ast;

grammar;

pub Hcl: () = {
    Body* => println!("Body: {:#?}", <>),
};

Body: ast::Statement = {
    <b:Block> => b,
    <a:Attribute> => a,
};

Attribute: ast::Statement = {
    <i:Identifier> "=" Expression => {
        ast::Statement {
            node: ast::StatementType::Attribute {
                identifier: i
            }
        }
    }
};

Block: ast::Statement = {
    <i:Identifiers+> "{" <body:Body+> "}" => {
        let mut blocks = vec![];
        let mut attrs = vec![];

        for stmt in body {
            match stmt.node {
                ast::StatementType::Block { .. } => blocks.push(stmt),
                ast::StatementType::Attribute { .. } => attrs.push(stmt),
            }
        }

        ast::Statement {
            node: ast::StatementType::Block {
                block_identifiers: i,
                attributes: attrs,
                child_blocks: blocks,
            }
        }
    },
};

IdentifierList: () = {
    IdentifierList Identifiers,
    Identifiers,
};

Identifiers: String = {
    Identifier,
    QuotedIdentifier,
};

Expression: () = {
    Operation,
    Conditional,
    TemplateInterpolation,
};

TemplateInterpolation: () = {
    "${" ExprTerm "}",
    "${" "~" ExprTerm "~" "}",
};

Conditional: () = {
    ExprTerm "?" ExprTerm ":" ExprTerm,
};

// Precedence: highest to lowest.
// Level    Operators
//   6      * / %
//   5      + -
//   4      > >= < <=
//   3      == !=
//   2      &&
//   1      ||
Operation: () = {
    OperationUnary,
    OperationBinary,
};

OperationUnary: () = {
    "-" ExprTerm,
    "!" ExprTerm,
};

OperationBinary: () = {
    OperationOr,
};

// Precedence is created by adding nonterminals with higher precedence to the production rules.
// "Itself plus its child"
// '||' has the lowest precedence.
OperationOr: () = {
    OperationOr "||" OperationAnd,
    OperationAnd,
};

OperationAnd: () = {
    OperationAnd "&&" OperationEq,
    OperationEq,
};

OperationEq: () = {
    OperationEq "==" OperationComp,
    OperationEq "!=" OperationComp,
    OperationComp,
};

OperationComp: () = {
    OperationComp ">" OperationAddSub,
    OperationComp "<" OperationAddSub,
    OperationComp ">=" OperationAddSub,
    OperationComp "<=" OperationAddSub,
    OperationAddSub,
};

OperationAddSub:() = {
    OperationAddSub "+" OperationMulDiv,
    OperationAddSub "-" OperationMulDiv,
    OperationMulDiv,
};

OperationMulDiv: () = {
    OperationMulDiv "*" ExprTerm,
    OperationMulDiv "/" ExprTerm,
    OperationMulDiv "%" ExprTerm,
    ExprTerm,
};

ExprTerm: () = {
    LiteralValue,
    CollectionValue,
    // TemplateExpr,  // TODO: it can't parse newlines for some reason
    Identifiers,
    FunctionCall,
    ForExpr,
    ExprTerm Splat,
    "(" Expression ")",
};

LiteralValue:() = {
    Number,
    "true",
    "false",
    "null",
};

CollectionValue: () = {
    Tuple,
    Object,
};

Tuple: () = {
    "[" ExpressionCommaList? "]",
};

ExpressionCommaList: () = {

    Expression "," ExpressionCommaList,
    Expression,
};

Object: () = {
    "{" ObjectCommaList? "}",
};

ObjectCommaList: () = {
    Expression "=" Expression,
    Expression "=" Expression "," ObjectCommaList
};


Splat: () = {
    "." "*",
    "." Identifier,     // GetAttr
    "[" "*" "]",
    "[" Expression "]", // Index
};

FunctionCall: () = {
    Identifier "(" Arguments? ")"
};

Arguments: () = {
    ExpressionCommaList
};

ForExpr: () = {
    ForTupleExpr,
    ForObjectExpr,
};

ForTupleExpr: () = {
    "[" ForIntro Expression ForCond? "]"
};

ForObjectExpr: () = {
    "{" ForIntro Expression "=>" Expression "..."? ForCond? "}"
};

ForIntro: () = {
    "for" IdentifierCommaList "in" Expression ":"
};

ForCond: () = {
    "if" Expression
};

IdentifierCommaList: () = {
    Identifier,
    Identifier "," IdentifierCommaList
};

TemplateExpr: () = {
    // TODO: quotedTemplate (a double-quoted string with escaped quotes)
    Heredoc Identifier "\n" IdentifierList "\n"
};

QuotedIdentifier: String = r#""[a-zA-Z_][a-zA-Z_0-9]*""# => <>.to_string();
Identifier: String = r#"[a-zA-Z_][a-zA-Z_0-9]*"# => <>.to_string();
Number: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
Heredoc: String = r"<<-?" => <>.to_string();
