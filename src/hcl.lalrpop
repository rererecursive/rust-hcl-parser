use std::str::FromStr;
use crate::ast;

grammar;

pub Hcl: ast::Hcl = {
    <b:Body*> => {
        ast::Hcl {
            statements: b
        }
    }
};

Body: ast::Statement = {
    <b:Block> => b,
    <a:Attribute> => a,
};

Attribute: ast::Statement = {
    <i:Identifier> "=" <e:Expression> => {
        ast::Statement {
            node: ast::StatementType::Attribute {
                identifier: i,
                expression: ast::Expression {
                    node: e,
                }
            }
        }
    }
};

Block: ast::Statement = {
    <i:Identifiers+> "{" <body:Body+> "}" => {
        let mut blocks = vec![];
        let mut attrs = vec![];

        for stmt in body {
            match stmt.node {
                ast::StatementType::Block { .. } => blocks.push(stmt),
                ast::StatementType::Attribute { .. } => attrs.push(stmt),
            }
        }

        ast::Statement {
            node: ast::StatementType::Block {
                block_identifiers: i,
                attributes: attrs,
                child_blocks: blocks,
            }
        }
    },
};

Identifiers: String = {
    Identifier,
    QuotedIdentifier,
};

Expression: ast::ExpressionType = {
    Operation => ast::ExpressionType::Null {},
    Conditional => ast::ExpressionType::Null {},
    TemplateInterpolation => ast::ExpressionType::TemplateInterpolation { text: "temp".to_string() },
};

TemplateInterpolation: () = {
    "${" Term "}",
    "${" "~" Term "~" "}",
};

Conditional: () = {
    Term "?" Term ":" Term,
};

// Precedence: highest to lowest.
// Level    Operators
//   6      * / %
//   5      + -
//   4      > >= < <=
//   3      == !=
//   2      &&
//   1      ||
Operation: () = {
    OperationUnary,
    OperationBinary,
};

OperationUnary: () = {
    "-" Term,
    "!" Term,
};

OperationBinary: () = {
    OperationOr,
};

// Precedence is created by adding nonterminals with higher precedence to the production rules.
// "Itself plus its child"
// '||' has the lowest precedence.
OperationOr: () = {
    OperationOr "||" OperationAnd,
    OperationAnd,
};

OperationAnd: () = {
    OperationAnd "&&" OperationEq,
    OperationEq,
};

OperationEq: () = {
    OperationEq "==" OperationComp,
    OperationEq "!=" OperationComp,
    OperationComp,
};

OperationComp: () = {
    OperationComp ">" OperationAddSub,
    OperationComp "<" OperationAddSub,
    OperationComp ">=" OperationAddSub,
    OperationComp "<=" OperationAddSub,
    OperationAddSub,
};

OperationAddSub:() = {
    OperationAddSub "+" OperationMulDiv,
    OperationAddSub "-" OperationMulDiv,
    OperationMulDiv,
};

OperationMulDiv: () = {
    OperationMulDiv "*" Term,
    OperationMulDiv "/" Term,
    OperationMulDiv "%" Term,
    Term,
};

Term: () = {
    NumberValue,
    NullValue,
    BooleanValue,
    CollectionValue,
    // TemplateExpr,  // TODO: it can't parse newlines for some reason
    Identifiers,
    FunctionCall,
    ForExpr,
    Term Splat,
    "(" Expression ")",
};

NumberValue: ast::Term = {
    <n:Number> => {
        ast::Term {
            node: ast::TermType::Number {
                value: n
            }
        }
    }
};

NullValue: ast::Term = {
    "null" => {
        ast::Term {
            node: ast::TermType::Null
        }
    },
};

BooleanValue: ast::Term = {
    "true" => {
        ast::Term {
            node: ast::TermType::Boolean {
                value: true
            }
        }
    },
    "false" => {
        ast::Term {
            node: ast::TermType::Boolean {
                value: false
            }
        }
    }
};

CollectionValue: () = {
    Tuple,
    Object,
};

Tuple: () = {
    "[" ExpressionCommaList? "]",
};

ExpressionCommaList: () = {

    Expression "," ExpressionCommaList,
    Expression,
};

Object: () = {
    "{" ObjectCommaList? "}",
};

ObjectCommaList: () = {
    Expression "=" Expression,
    Expression "=" Expression "," ObjectCommaList
};


Splat: () = {
    "." "*",
    "." Identifier,     // GetAttr
    "[" "*" "]",
    "[" Expression "]", // Index
};

FunctionCall: () = {
    Identifier "(" Arguments? ")"
};

Arguments: () = {
    ExpressionCommaList
};

ForExpr: () = {
    ForTupleExpr,
    ForObjectExpr,
};

ForTupleExpr: () = {
    "[" ForIntro Expression ForCond? "]"
};

ForObjectExpr: () = {
    "{" ForIntro Expression "=>" Expression "..."? ForCond? "}"
};

ForIntro: () = {
    "for" IdentifierCommaList "in" Expression ":"
};

ForCond: () = {
    "if" Expression
};

IdentifierCommaList: () = {
    Identifier,
    Identifier "," IdentifierCommaList
};

TemplateExpr: () = {
    // TODO: quotedTemplate (a double-quoted string with escaped quotes)
    Heredoc Identifier "\n" Identifiers* "\n"
};

QuotedIdentifier: String = r#""[a-zA-Z_][a-zA-Z_0-9]*""# => <>.to_string();
Identifier: String = r#"[a-zA-Z_][a-zA-Z_0-9]*"# => <>.to_string();
Number: u32 = r"[0-9]+" => u32::from_str(<>).unwrap();
Heredoc: String = r"<<-?" => <>.to_string();
